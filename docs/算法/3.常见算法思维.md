# 常见算法思维

常见算法思维：

1. 分治法
2. 迭代法
3. 枚举法
4. 回溯法
5. 贪心法
6. 动态规划



## 1. 分治法

英语里面叫做 divide and Conquer

**核心思想**

将一个复杂的问题分解成多个简单的子问题，递归地求解这些子问题，如果子问题还是比较复杂，那么就继续进行拆分。最后再将所有子问题的解合并成最终解。



**核心步骤**

1. 分解：将原来的问题分解为多个小问题
2. 求解：递归的解决所有的子问题
3. 合并：将所有子问题的解合并成原来问题的解。



**举例：归并排序**

归并排序就是典型的使用的是分治的思想：

<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2025-02-11-083546.png" alt="image-20250211163545350" style="zoom:50%;" />

整个归并排序会经历：

1. 分解：将待排序的数组不断的分成两个部分，直到不能再分解
2. 求解：递归的将两个部分的数组进行归并排序
3. 合并：将两个排序后的数组将其合并为一个排序好的数组



**分治法的优缺点**

- 优点：简化问题。通过分解一个大问题，将其全部转换为较为简单的子问题，从而易于求解。
- 缺点：往往需要一些额外的空间。空间复杂度一般在 O(n) 左右。分治法往往需要额外的存储空间来存储分解后的子问题。



## 2. 迭代法

英语叫做 Iteration

**核心思想**

重复执行一系列步骤，直到满足某个条件或达到预定目标。每次迭代都在一定程度上修改问题的状态，最终通过不断的更新和计算得到问题的解。



**核心步骤**

1. 初始化：先设置一个初始值，准备进入迭代。
2. 条件判断：在每次迭代开始之前，需要检查当前状态是否满足结束条件，如果满足结束条件，那么就停止迭代。

3. 更新：需要不停的去更新状态，从而进入下一次迭代。

4. 重复：一直执行迭代

其实，循环就是典型的迭代的思想。



**举例：计算递增序列的和**

1+2+3+4+ ....+ 99+100

```js
let sum = 0;
for(let i = 1; i <= 100; i++){
  sum += i;
}
```

上面的解法，背后采用的就是迭代的思想。



## 3. 枚举法

英语叫做 Enumeration

**核心思想**

列出**所有可能的选项**，并逐一检查每一个选项，判断是否符合问题的约束条件。



**核心步骤**

1. 穷举所有可能的解
2. 检查每个解：看每一个解是否符合要求
3. 选择合适的解



**举例：力扣第 1 题**

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值 target**  的那 **两个** 整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。你可以按任意顺序返回答案。

示例 1

```js
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
```

示例 2

```js
输入：nums = [3,2,4], target = 6
输出：[1,2]
```

示例 3

```js
输入：nums = [3,3], target = 6
输出：[0,1]
```

这道题大家能够想到的就是枚举的方式，从第一个数开始，和后面的数进行组合，看是否符合要求。

```js
function twoSum(nums, target) {
  // 遍历数组从第一个到倒数第二个
  for (let i = 0; i < nums.length - 1; i++) {
    // 遍历数组从第二个到最后一个
    for (let j = i + 1; j < nums.length; j++) {
      if (nums[i] + nums[j] === target) {
        return [i, j];
      }
    }
  }
}

const nums = [2, 7, 11, 15];
const target = 9;
console.log(twoSum(nums, target));

const nums2 = [3, 2, 4];
const target2 = 6;
console.log(twoSum(nums2, target2));
```

虽然上面的算法也用到了迭代的操作，但是我们迭代是为了枚举出所有的和，迭代仅仅是实现手段，算法背后的核心思想仍然是枚举。


## 回溯算法

什么是回溯

使用 DFS 查找二叉树所有的路径：

<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2025-03-17-051939.png" alt="image-20250317131939163" style="zoom:40%;" />

回溯本质上是一种 **暴力穷举算法**，把所有的可能都列举出来，所以没有剪枝情况下的回溯是比较低效的。正因为这样，**一般回溯会进行剪枝操作**。所谓剪枝，指的就是当搜索到某个分支不可能得到可行解（或更优解）时，就 **提前结束** 该分支，避免进行无意义的搜索。



**具体示例**

🙋[1, 2, 3] 这 3 个数有多少种组合呢？

就是将所有的结果都穷举出来：

- 第一位选 1，第二位从 [2, 3] 里面去选，第二位选择的是什么又影响第三位
- 第一位选 2，第二位从 [1, 3] 里面去选，第二位选择的是什么又影响第三位
- 第一位选 3，第二位从 [1, 2] 里面去选，第二位选择的是什么又影响第三位

这里可以将选择的过程抽象为一颗树：

![image-20250317133402254](https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2025-03-17-053402.png)



**算法模板**

整个回溯算法，可以看作是一个树的遍历过程，因此整个回溯算法有如下的算法模板：

```js
function backtrack(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtrack(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2025-03-17-053838.png" alt="image-20250317133838706" style="zoom:50%;" />



**回溯能解决的问题**

1. 组合问题：N个数按照一定的规则找出 k 个数的集合
2. 切割问题：一个字符串按照一定的规则进行切割，看有多少种切割方式
3. 子集问题：一个 N 个数的集合里面有多少符合条件的子集
4. 排列问题：N 个数按照一定规则来进行排列，看有多少种排列的方式
5. 棋盘问题

## 贪心算法

贪心的本质是选择**每一阶段的局部最优**，从而达到**全局最优**。

🙋提问： 例如，有一堆钞票，你可以拿走十张，如果想达到最大的金额，你要怎么拿？

回答：每一次都拿走当前钞票面值最大的那一张。最终就是拿走的是最大数额的钱。每一次拿走的最大就是局部最优，最终拿走的面值的总额就是全局最优。



**题目**

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 `i`，都有一个胃口值 `g[i]`，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 `j`，都有一个尺寸 `s[j]` 。如果 `s[j] >= g[i]`，我们可以将这个饼干 `j` 分配给孩子 `i` ，这个孩子会得到满足。你的目标是满足尽可能多的孩子，并输出这个最大数值。

示例 1

>输入: g = [1,2,3], s = [1,1]
>输出: 1
>解释:
>你有三个孩子和两块小饼干，3 个孩子的胃口值分别是：1,2,3。
>虽然你有两块小饼干，由于他们的尺寸都是 1，你只能让胃口值是 1 的孩子满足。
>所以你应该输出 1。

示例 2

>输入: g = [1,2], s = [1,2,3]
>输出: 2
>解释:
>你有两个孩子和三块小饼干，2 个孩子的胃口值分别是 1,2。
>你拥有的饼干数量和尺寸都足以让所有孩子满足。
>所以你应该输出 2。



**代码实现**

```js
/**
 * g - 小孩数组，数字代表胃口值 [1,2,3] 3 个孩子的胃口值分别是：1,2,3
 * s - 饼干数组，数字代表尺寸 [1,2,3] 3块饼干，尺寸分别是 1,2,3
 */
function findContentChildren(g, s) {
 	// 1. 先对小孩的胃口值还有饼干尺寸进行排序
  g.sort((a, b) => a - b); // 对胃口值排序
  s.sort((a, b) => a - b); // 对饼干尺寸进行排序
  
  let count = 0; // 记录满足孩子的数量
  let i = 0; // 孩子数组的指针
  let j = 0; // 饼干数组的指针
  
  // 同时遍历孩子和饼干的数组
  while(i < g.length && j < s.length){
    if(s[j] >= g[i]){
      count++;
      i++; // 下一个孩子
      j++; // 当前的饼干也被用了，移动到下一块饼干
    } else {
      // 因为饼干是排好序了的，直接尝试下一块饼干
      j++;
    }
  }
  
  return count;
}
```



【有一堆钞票，拿走十张，要达到最大金额】

```js
function getMaxAmount(bills){
  bills.sort((a, b) => b - a); // 从大到小排序
  
  const selectedBills = bills.slice(0, 10);
  
  const totalAmount = selectedBills.reduce((sum, bill)=> sum + bill, 0);
  
  return {selectedBills, totalAmount}
}

// 一堆钞票
const bills = [50, 100, 5, 20, 10, 200, 1000, 500, 50, 5, 10, 50, 100, 200, 500];
const result = getMaxAmount(bills);
console.log(result);
```

## 动态规划

动态规划，英语叫做 Dynamic Programming，简称 DP，这是一种**解决复杂问题的方法**，其最最最核心的思想，就是 **将问题分解成子问题**，只要子问题解决了，那么这个复杂问题也就解决了。

> 和分治法的区别：
>
> 核心区别在于**子问题是否存在重叠性**，相同的子问题可能会被多次计算，动态规划通过**存储子问题的结果**（记忆化搜索或自底向上计算）来**避免重复计算**。相比之下，分治法通常将问题拆分成**相互独立的子问题**，然后合并子问题的结果。

### DP 核心特点

1. 最优子结构（Optimal Substructure）
2. 重叠子问题（Overlapping Subproblems）
3. 存储子问题的解（Memoization / Tabulation）

#### 1. 最优子结构

最优子结构指的是：**某个问题的最优解可以通过其子问题的最优解来构造**。换句话说，假如你想求问题 P 的最佳答案，那么可以先把 P 拆分为若干子问题 P<sub>1</sub>、P<sub>2</sub>、P<sub>3</sub>、P<sub>4</sub> ..... ，并把它们分别求出这些子问题的最优解，然后再根据子问题的最优解组合出 P 的最优解。

实际上，拥有最优子结构是许多算法设计策略（包括分治法、贪心算法、动态规划）的一个重要前提。对于 DP 来说，没有最优子结构就无法通过拆分子问题来推导原问题的解。



一个实际的例子：斐波那契数列

计算斐波那契数列的第 n 项，这里就需要拆解成 n-1 项和 n-2 项，然后得到这两个子问题的最优解，最终能够组合得到第 n 项的最优解。



#### 2. 重叠子问题

重叠子问题指的是：在将原问题分解为若干子问题后，这些子问题在问题的求解过程中会重复出现，从而导致你重复的计算多次。

分治法虽然也会把问题拆分成子问题，但在很多分治问题里，这些子问题要么不重叠，要么仅仅少量重叠；而动态规划则通常在大规模、带有递推性质的场景中，**大量重复**的子问题**被反复计算**。如果不加以**记录**，就会做许多 **重复计算**，从而影响效率。



一个例子：斐波那契数列

- F(5) = F(4) + F(3)
- F(4) = F(3) + F(2)
    - F(3) = F(2) + F(1)
- F(3) = F(2) + F(1)



#### 3. 存储子问题的解

对于不断重叠出现的子问题，如果我们能把它们的解存储起来，下次遇到相同的子问题就直接取结果，而不是重新计算，便能大大降低算法的时间复杂度。

在实现层面，通常有两种形式：

1. 记忆化搜索（Memoization，Top-Down）自上而下
2. 表格法（Tabulation，Bottom-Up）自下而上

存储子问题解这一特性让动态规划和纯粹的分治算法区分开来，也显著地提高了运算效率。纯分治往往不刻意缓存子问题结果，而是“算完就走”，需要时再重新计算；而 DP 会把结果记下来，这就是动态规划“动态”这个概念体现的地方：我们可以说状态是“动态地”沿着子问题规模的增加而得到维护和更新。



### 状态转移方程

**状态转移方程** 就是描述 **从一个状态如何过渡到另一个状态** 的规则或**公式**。它本质上是一种 **递推/递归关系**，用来指导我们如何从小规模子问题的解，一步步累积得到大规模问题的解。

换句话说：一个问题的解可以由它的子问题解来合成。“状态转移方程”就把这**种合成过程**用正式的数学或伪代码表达出来。

例如斐波那契数列可以写成：
$$
F(n)=F(n−1)+F(n−2)，F(0)=0,F(1)=1
$$
而在背包问题中的，若令 `dp[i][c]` 表示在只考虑前 `i` 个物品、容量为 `c` 的情况下能达到的最大价值，那么状态转移方程就可以写成：
$$
dp[i][c] = \max\Bigl( dp[i-1][c],\, dp[i-1][c - \text{weight}_i] + \text{value}_i \Bigr)
$$
一般来讲，DP 的题目中状态转移方程列举出来了，题目基本上就完成一半了。

那么如何来列出这个重要的状态转移方程呢？**多练题**



### 具体实践

#### 题目

**斐波那契数列**（Fibonacci Sequence）指的是这样一个数列：

- F(0)=0
- F(1)=1
- 从第二项开始，每一项都等于前两项之和，即：

$$
F(n)=F(n−1)+F(n−2)，n≥2
$$

**要求：**给定一个整数 `n`，请你计算 F(n) 并返回结果。

**举例：**

- 当 n=0 时，F(0)=0
- 当 n=1 时，F(1)=1
- 当 n=5 时，F(5)=5（序列为 0, 1, 1, 2, 3, 5, 8, 13, 21...）



#### 解题思路

最基础、最直观的思路是**递归**：`F(n) = F(n-1) + F(n-2)`。但如果我们直接用“自顶向下”的纯递归算法，会**有大量重复计算**。例如，计算 `F(5)` 时，需要先算 `F(4) + F(3)`；计算 `F(4)` 又要算 `F(3) + F(2)`……很多重复。“动态规划”能通过 **存储子问题解** 来避免重复计算，将原本指数级复杂度降低到线性或更优。



**最优子结构**

最优子结构指的是：**原问题的最优解可以由其子问题的最优解组合而成**。

对于斐波那契数列，`F(n) = F(n-1) + F(n-2)` 正说明了：要想得到 `F(n)`，只需要先把 `F(n-1)` 和 `F(n-2)` 计算好（它们各自都是各自子问题的“最优解”——对于数列而言，就是唯一且正确的值），然后将这两个结果相加即可。



**重叠子问题**

斐波那契数列的子问题有大量重叠：

- 比如纯递归计算 `F(5)` 时：
    - `F(5)` 会调用 `F(4)` 和 `F(3)`
    - `F(4)` 会调用 `F(3)` 和 `F(2)`
    - 可以看到，`F(3)` 被反复调用了多次，这就是**子问题重叠**。



**存储子问题的解**

在动态规划中，通过**存储**已经算好的子问题 `F(k)` 的值，下次再需要时就直接取用，不必再次计算。

实现方式上，可以**记忆化搜索（Memoization）** 或 **表格法（Tabulation）**。对斐波那契来说，表格法相对来讲会更简单，开一个数组 `dp`，其中 `dp[i]` 用来存储 `F(i)`。



**状态转移方程**

斐波那契数列之所以适合作为动态规划的入门题，就是因为题目中已经将状态转移方程告诉你了。

- 状态定义：用 `dp[i]` 来表示 `F(i)` 的值，即斐波那契数列第 `i` 项。

- 状态转移方程：
  $$
  dp[i]=dp[i−1]+dp[i−2]
  $$

- 初始条件：
  $$
  dp[0]=0,dp[1]=1
  $$

- 计算顺序：当我们用“表格法”解斐波那契时，可以从 `i = 2` 往后依次计算，直至 `i = n`，这样前面的 `dp[0], dp[1]... dp[i-1]`、`dp[i-2]` 都已经就绪，可用于计算下一步。



**代码实现**

使用表格法（自下而上）

```js
/**
 * n - 斐波那契的第 n 项
 */
function fibonacci(n){
  if(n < 2){
    return n;
  }
  
  // 接下来我们需要一个 dp 数组来记录状态
  const dp = new Array(n+1);
  
  // 接下来做初始化
  dp[0] = 0;
  dp[1] = 1
  
  for(let i = 2; i <= n; i++){
    // 填充表格
    dp[i] = dp[i - 1] + dp[i - 2];
  }
  
  return dp[n];
}
```
