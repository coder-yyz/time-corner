# 二叉树遍历

## **二叉树存储**

实际开发中，一般会使用数组来存储树结构，通过数组，我们可以非常方便的找到一个节点的所有亲属。

<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2025-02-24-070439.png" alt="image-20250224150439190" style="zoom:50%;" />

- 寻找父节点：`Math.floor((当前节点的下标 - 1) / 2)`，例如：

  | 子节点 | 父节点 |
    | :----: | :----: |
  |   1    |   0    |
  |   2    |   0    |
  |   3    |   1    |
  |   4    |   1    |

- 寻找左分支节点：`当前节点下标 * 2 + 1`，例如：

  | 父节点 | 左分支节点 |
    | :----: | :--------: |
  |   0    |     1      |
  |   1    |     3      |
  |   2    |     5      |

- 寻找右分支节点：`当前节点下标 * 2 + 2`，例如：

  | 父节点 | 左分支节点 |
    | :----: | :--------: |
  |   0    |     2      |
  |   1    |     4      |
  |   2    |     6      |



## **完全二叉树遍历**

<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2025-02-26-012002.png" alt="image-20250226092001455" style="zoom:40%;" />

```js
class TreeNode {
  constructor(value) {
    this.value = value; // 节点的值
    this.left = null; // 左子树
    this.right = null; // 右子树
  }
}

// 构建上面的完全二叉树
const root = new TreeNode("A");
root.left = new TreeNode("B");
root.right = new TreeNode("C");
root.left.left = new TreeNode("D");
root.left.right = new TreeNode("E");
root.left.left.left = new TreeNode("H");
root.left.left.right = new TreeNode("I");
root.left.right.left = new TreeNode("J");
root.left.right.right = new TreeNode("K");
root.right.left = new TreeNode("F");
root.right.right = new TreeNode("G");
root.right.left.left = new TreeNode("L");
root.right.left.right = new TreeNode("M");
root.right.right.left = new TreeNode("N");
root.right.right.right = new TreeNode("O");
```

1. 前序遍历

   ```
   根节点 --> 左子树 --> 右子树
   ```

   遍历出来的顺序如下：

   ```
   A -> B -> D -> H -> I -> E -> J -> K -> C -> F -> L -> M -> G -> N -> O
   ```

   ```js
   function preOrder(root){
     if(root === null) return;
     
     // 访问根节点
     console.log(root.value);
     
     // 遍历左子树
     preOrder(root.left);
     
     // 遍历右子树
     preOrder(root.right);
   }
   ```



2. 中序遍历

   ```
   左子树 --> 根节点 --> 右子树
   ```

   中序遍历的具体顺序可以看节点投影，投影出来的线性顺序就是遍历出来的顺序

   <img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2025-02-26-013652.png" alt="image-20250226093651508" style="zoom:40%;" />

   ```
   H -> D -> I -> B -> J -> E -> K -> A -> L -> F -> M -> C -> N -> G -> O
   ```

   ```js
   function inOrder(root){
     if(root === null) return;
     
     // 遍历左子树
     inOrder(root.left);
     
      // 访问根节点
     console.log(root.value);
     
     // 遍历右子树
     inOrder(root.right);
   }
   ```



3. 后序遍历

   ```
   左子树 --> 右子树 --> 根节点
   ```

   ```
   H -> I -> D -> J -> K -> E -> B -> L -> M -> F -> N -> O -> G -> C -> A
   ```

   ```js
   function postOrder(root){
     if(root === null) return;
     
     // 遍历左子树
     postOrder(root.left);
     
     // 遍历右子树
     postOrder(root.right);
     
     // 访问根节点
     console.log(root.value);
   }
   ```

## 二叉树深度优先搜索


**深度优先搜索**

所谓深度优先搜索，顾名思义，就是先往下找，直到不能再往下了，再切换到平层的节点，切换到平层的节点后，继续往下进行搜索。

前序遍历，遍历的顺序为根节点 -> 左子树 -> 右子树

<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2025-02-26-012002.png" alt="image-20250226092001455" style="zoom:40%;" />

前序遍历出来的顺序为：

```js
A -> B -> D -> H -> I -> E -> J -> K -> C -> F -> L -> M -> G -> N -> O
```

深度优先搜索（Depth-First-Search，简称 DFS）也是按照这样的顺序。

代码实现：

```js
class TreeNode{
  constructor(value){
    this.value = value;
    this.left = null;
    this.right = null;
  }
}

// 初始化二叉树
const root = new TreeNode("A");
root.left = new TreeNode("B");
root.right = new TreeNode("C");
root.left.left = new TreeNode("D");
root.left.right = new TreeNode("E");
root.left.left.left = new TreeNode("H");
root.left.left.right = new TreeNode("I");
root.left.right.left = new TreeNode("J");
root.left.right.right = new TreeNode("K");
root.right.left = new TreeNode("F");
root.right.right = new TreeNode("G");
root.right.left.left = new TreeNode("L");
root.right.left.right = new TreeNode("M");
root.right.right.left = new TreeNode("N");
root.right.right.right = new TreeNode("O");

function depthFirstSearch(root, target){
  if(root === null) return false;
  
  if(root.value === target) return true;
  
  const leftResult = depthFirstSearch(root.left, target);
  const rightResult = depthFirstSearch(root.right, target);
  
  return leftResult || rightResult;
}
console.log(depthFirstSearch(root, "J"));
```

## 二叉树广度优先搜索

广度优先搜索（Breadth-First-Search，简称 BFS），顾名思义，就是先按照每一层的顺序来进行搜索，如下图所示：

<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2025-02-26-032421.png" alt="image-20250226112420587" style="zoom:40%;" />

因此其实在前序、中序、后序遍历的基础上，实际上还有一个层序遍历。

层序遍历实现：

```js
function levelOrder(root){
  if(root === null) return;
  
  const queue = []; // 用于存储每一层的节点
  queue.push(root);
  
  while(queue.length > 0){
    const node = queue.shift(); // 从队列里面拿出最前面的节点
    console.log(node.value);
    
    if(node.left !== null) queue.push(node.left);
    if(node.right !== null) queue.push(node.right);
  }
}
```

广度优先搜索：

```js
class TreeNode {
  constructor(value) {
    this.value = value;
    this.left = null;
    this.right = null;
  }
}

// 初始化二叉树
const root = new TreeNode("A");
root.left = new TreeNode("B");
root.right = new TreeNode("C");
root.left.left = new TreeNode("D");
root.left.right = new TreeNode("E");
root.left.left.left = new TreeNode("H");
root.left.left.right = new TreeNode("I");
root.left.right.left = new TreeNode("J");
root.left.right.right = new TreeNode("K");
root.right.left = new TreeNode("F");
root.right.right = new TreeNode("G");
root.right.left.left = new TreeNode("L");
root.right.left.right = new TreeNode("M");
root.right.right.left = new TreeNode("N");
root.right.right.right = new TreeNode("O");


function breadthFirstSearch(root, target){
  if(root === null) return;
  
  const queue = []; // 用于存储每一层的节点
  queue.push(root);
  
  while(queue.length > 0){
    const node = queue.shift(); // 从队列里面拿出最前面的节点
    
    if(node.value === target) return true;
    
    if(node.left !== null) queue.push(node.left);
    if(node.right !== null) queue.push(node.right);
  }
  return false;
}
console.log(breadthFirstSearch(root, "J"));
```



## 二叉树的比较

现在有如下两颗二叉树：

<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2025-03-06-074130.png" alt="image-20250306154129384" style="zoom:30%;" />

很明显，这两颗二叉树的内容是 **完全一致** 的，这里我们需要书写一个方法，来判断两颗树是否一致。

```js
// 定义二叉树的节点结构
class TreeNode {
  constructor(value) {
    this.value = value; // 节点的值
    this.left = null; // 左子树
    this.right = null; // 右子树
  }
}

// 构建第一颗二叉树
const a1 = new TreeNode("a");
const b1 = new TreeNode("b");
const c1 = new TreeNode("c");
const d1 = new TreeNode("d");
const e1 = new TreeNode("e");
const f1 = new TreeNode("f");
const g1 = new TreeNode("g");
a1.left = c1;
a1.right = b1;
c1.left = f1;
c1.right = g1;
b1.left = d1;
b1.right = e1;

// 构建第二颗二叉树
const a2 = new TreeNode("a");
const b2 = new TreeNode("b");
const c2 = new TreeNode("c");
const d2 = new TreeNode("d");
const e2 = new TreeNode("e");
const f2 = new TreeNode("f");
const g2 = new TreeNode("g");
a2.left = c2;
a2.right = b2;
c2.left = f2;
c2.right = g2;
b2.left = d2;
b2.right = e2;

/**
 * 比较两棵二叉树是否相同
 * @param {TreeNode|null} tree1 第一棵树的根节点
 * @param {TreeNode|null} tree2 第二棵树的根节点
 * @returns {boolean} 若相同返回 true，否则返回 false
 */
function compareTree(tree1, tree2) {
  // 两个根节点的引用是相同的
  if(tree1 === tree2) return true;
  
  // 如果其中一个为空另一个不为空
  if(
    (tree1 === null && tree2 !== null) ||
    (tree1 !== null && tree2 === null)
   ) return false;
  
  // 代码走到这里，说明 tree1 和 tree2 都不为 null
  // 可以访问 value
  if(tree1.value !== tree2.value) return false;
  
  // 递归的判断左右子树是否相同
  const leftResult = compareTree(tree1.left, tree2.left);
  const rightResult = compareTree(tree1.right, tree2.right);
  
  // 最后，左子树和右子树都必须相同
  return leftResult && rightResult;
}

// 调用 compareTree
console.log(compareTree(a1, a2)); // true
```

有些时候，在进行二叉树比较时，需要确定一个问题，那就是左右两颗子树交换位置算不算同一颗二叉树。比如下面的情况：

<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2025-03-06-081100.png" alt="image-20250306161100506" style="zoom:35%;" />

可以看到，这两颗二叉树实际上就是左右子树所在位置发生了互换，这在某些场景下会被认为是同一颗二叉树，这就好比：

<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2025-03-06-081445.png" alt="image-20250306161445713" style="zoom:50%;" />

小明的爸爸和妈妈只是交换了站的位置，但是他们仍然是一家人，不可能换个位置就变成两家人了。

```js
// 定义二叉树的节点结构
class TreeNode {
  constructor(value) {
    this.value = value; // 节点的值
    this.left = null; // 左子树
    this.right = null; // 右子树
  }
}

// 构建第一颗二叉树
const a1 = new TreeNode("a");
const b1 = new TreeNode("b");
const c1 = new TreeNode("c");
const d1 = new TreeNode("d");
const e1 = new TreeNode("e");
const f1 = new TreeNode("f");
const g1 = new TreeNode("g");
// 交换 a1 这颗树的左右子树
a1.right = c1;
a1.left = b1;
c1.left = f1;
c1.right = g1;
b1.left = d1;
b1.right = e1;

// 构建第二颗二叉树
const a2 = new TreeNode("a");
const b2 = new TreeNode("b");
const c2 = new TreeNode("c");
const d2 = new TreeNode("d");
const e2 = new TreeNode("e");
const f2 = new TreeNode("f");
const g2 = new TreeNode("g");
a2.left = c2;
a2.right = b2;
c2.left = f2;
c2.right = g2;
b2.left = d2;
b2.right = e2;

/**
 * 比较两棵二叉树是否相同
 * @param {TreeNode|null} tree1 第一棵树的根节点
 * @param {TreeNode|null} tree2 第二棵树的根节点
 * @returns {boolean} 若相同返回 true，否则返回 false
 */
function compareTree(tree1, tree2) {
  // 两个根节点的引用是相同的
  if (tree1 === tree2) return true;

  // 如果其中一个为空另一个不为空
  if ((tree1 === null && tree2 !== null) || (tree1 !== null && tree2 === null))
    return false;

  // 代码走到这里，说明 tree1 和 tree2 都不为 null
  // 可以访问 value
  if (tree1.value !== tree2.value) return false;

  // 递归的判断左右子树是否相同
  // const leftResult = compareTree(tree1.left, tree2.left);
  // const rightResult = compareTree(tree1.right, tree2.right);

  // 最后，左子树和右子树都必须相同
  // return leftResult && rightResult;

  const result1 =
    compareTree(tree1.left, tree2.left) &&
    compareTree(tree1.right, tree2.right);
  const result2 =
    compareTree(tree1.left, tree2.right) &&
    compareTree(tree1.right, tree2.left);
  return result1 || result2;
}

// 调用 compareTree
console.log(compareTree(a1, a2)); // true
```
