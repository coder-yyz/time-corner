# 评判算法的好坏

🙋如何评判一个算法的好坏呢？

回答：时间

10个数字

10万数字

实际运行的时间长多少？

**不光要了解不同算法在运行时间上的区别，更重要的是根据数据输入量的大小，算法运行时间的变化趋势**。



**如何求运行时间**

使用“步数”来描述运行时间。“1步”（就是指一个操作）就是计算的基本单位。

示例：对一堆乱序的数列进行排序

1. 从整个数列中寻找最小值
2. 将最小值和数列最左边的数字进行交换，回到步骤 1

计算步骤：

1. 如果数列中有 n 个数字，那么步骤 1 中“寻找最小值”的步骤只需要确认 n 个数字即可。

2. 将 “确认 1 个数字的大小” 作为操作的基本单位，需要时间 T<sub>c</sub> ，那么步骤 1 的运行时间就是 n * T<sub>c</sub> 。

3. “对两个数字进行交换” 也作为操作的基本单位，假设需要的时间为 T<sub>s</sub>  。那么步骤 1 和步骤 2 总共重复 n 次，每经过 1 轮，需要查找的数字就减少 1 个，因此总的运行时间为：
   $$
   (n\times Tc + Ts)+((n-1)\times Tc + Ts)+((n-2)\times Tc + Ts)+ .... + (2\times Tc+Ts)+(1\times Tc+Ts)
   $$

   换算下来就是：
   $$
   \frac{1}{2}Tc\times n \times (n+1) + Ts \times n
   $$
   进一步换算：
   $$
   \frac{1}{2} \times Tc \times n^2 + (\frac{1}{2} \times Tc + Ts) \times n
   $$




**运行时间表示法**

Tc 和 Ts 都是基本单位，与输入无关。会根据输入变化而变化的只有数列的长度 n。

n 越大，上面式子中的 n<sup>2</sup> 也就越大，其他部分就相对变小了。也就是说，对式子影响最大的是 n<sup>2</sup>。

将结果表示称下面的形式：
$$
\frac{1}{2} \times Tc \times n^2 + (\frac{1}{2} \times Tc + Ts) \times n = O(n^2)
$$
`O(n^2)`所传达的信息：排序算法的运行时间与输入量 n 的平方成正比。



如果某个算法的运行时间为：
$$
3 \times n \times logn + 2 \times Ty \times n
$$
如何表达？

使用大O表示法表示出来为`O(nlogn)`



这样的表示方法被称之为大 O 表示法。这里的 O 是来自于英语的 Order（表示“阶”的意思）

它最早由数学家 Paul Bachmann 于 1894 年引入，在计算机科学中被 Donald Knuth 在 1970 年代普及。该表示法用来描述一个函数的**增长速率**，其核心思想是描述一个算法在 **最坏情况** 下，输入数据量增加时，时间或空间需求的 **增长趋势**，也就是算法的 **上界**。



**其他表示法**

1. Ω 表示法（Big Omega Notation）：用于描述一个算法的 **下界**，算法在最好的情况下的一个增长趋势。
2. Θ 表示法（Big Theta Notation）：用于描述算法 **精确增长的速率**，也就是算法在最坏和最好的情况下的增长趋势相同。
3. o 表示法（Little o Notation）：用来表示一个算法的增长速度**严格小于**某个复杂度的增长，意味着算法的增长速度比给定函数增长得更慢。
4. ω 表示法（Little Omega Notation）：用来表示一个算法的增长速度**严格大于**某个复杂度的增长，意味着算法的增长速度至少比给定函数快。

在实际算法测量中，使用得最广泛的仍然是大O表示法。



**复杂度**

无论是时间复杂度还是空间复杂度，评判的都是一种 **增长趋势**。

1. 时间复杂度：算法执行所需的时间随着输入规模 n 增长的一个变化趋势。
2. 空间复杂度：算法执行所需的内存空间随着输入规模 n 增长的一个变化趋势。


**常见时间复杂度**

时间复杂度衡量的是一种变化趋势。随着 n 增大，整个时间花费的 **变化趋势** 是怎样的。

1. O(1)
2. O(logn)
3. O(n)
4. O(nlogn)
5. O(n²)
6. O(2<sup>n</sup>)
7. O(n!)

上面的这几种复杂度，从上往下，随着 n 的增大，时间花费都不相同。越上面的，时间变化趋势越平缓性能越优；越往下面，时间增长趋势越陡峭，性能就越低。

<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-03-28-035621.png" alt="image-20220328115620995" style="zoom:50%;" />

**`O(1)`**

```js
let n = 100;
console.log(n);
```

`O(1)` 的时间复杂度不会随着 n 的变化，运行时间有什么增加。



`O(logn)`

```js
for(let i = 1; i < n; i *= 2){
  // ...
}
```

因为每次迭代都是将 i 翻两倍，循环的次数是对数级别的。因此时间复杂度为 `O(logn)`

假设 n 是 8，就会循环 3 次。



`O(n)`

```js
for(let i = 1; i <= n; i++){
  //...
}
```

上面的代码，n 为多少，就会循环多少次，因此时间复杂度为 `O(n)` 级别。

假设 n 是 8，就会循环 8 次。



`O(nlogn)`

```js
for(let i = 0; i <= n; i++){
  let j = 1;
  while(j < n){
    j *= 2;
  }
}
```



`O(n²)`

```js
for(let i = 1; i <= n; i++){
  for(let j = 1; j <= n; j++){
    // ...
  }
}
```

依此类推，假设有三层循环，那么时间复杂度就是 `O(n^3)`



`O(2^n)`

比如递归算法。每多展开一层，运算的个数也就会翻 2 倍，以 2 的幂次方的规律增长。

<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-03-28-052721.png" alt="image-20220328132720591" style="zoom:50%;" />


**在大O表示法中，只有高阶的项才决定了算法最终的时间复杂度**。

O(n) + O(logn) = O(n)

O(n²) + O(n) = O(n²)



**常见的空间复杂度**

衡量的是随着 n 的增长，所使用的内存空间的一个增长趋势。

1. `O(1)`

```js
let i = 1;
i++;
let j = 2;
j++;
n = 10;
console.log(n);
```



2. `O(n)`

```js
let arr = new Array(n);
```

这里 n 有多大，就决定为数组开辟的内存空间有多大。



3. `O(n^2)`

```js
let arr = new Array(n);
for(let i = 0; i < n; i++){
  arr[i] = new Array(n);
}
```





🤔了解时间和空间复杂度的好处？

了解了时间和空间复杂度之后，以后在写代码的时候，就会自然而然的去想一下自己写的这段代码的性能如何。

需求：计算从 1 加到 n 的和

```js
let sum = 0;
for(let i = 1; i <= n; i++){
  sum += i;
}
```

上面这种解法，时间复杂度为 O(n)，但是我们现在换一种算法，采用数学里面等差数列的求和公式：

```js
let sum = (n * (n+1)) / 2
```

上面的解法，时间复杂度就从 O(n) 下降到了 O(1)

