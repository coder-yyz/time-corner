# 架构

## _Fabric_ 架构

Fabric 是 React Native 的新渲染系统，是传统渲染系统的概念演变。其核心原则是在 C++ 中统一更多的渲染逻辑，提高与主机平台的互操作性，并解锁 React Native 的新功能。从 2018 年开始进行新渲染器的开发，到了 2021 年，React Native 已经开始使用新渲染器。

### 使用新渲染器的动机以及好处

创建新的渲染架构是为了解锁一些旧架构无法提供的更好的用户体验。其中包括以下的一些场景：

- 通过改进主机视图和 React 视图之间的互操作性，渲染器能够同步测量和渲染 React 视图。 在旧的架构中，React Native 布局是异步的，当在宿主视图中嵌入 React Native 渲染视图时，会导致布局“跳转”问题。

- 通过支持多优先级和同步事件，渲染器可以优先考虑某些用户交互，以确保及时处理它们。

- 与 React Suspense 集成，允许在 React 应用程序中更直观地设计数据获取。

- 在 React Native 上启用 React 并发功能。

- 更容易为 React Native 实现服务器端渲染。

新架构还提供了代码质量、性能和可扩展性方面的优势：

- 类型安全：代码生成以确保跨 JS 以及不同平台的类型安全。代码生成使用 JavaScript 组件声明来作为生成 C++ 结构的事实来源。JavaScript 和宿主组件 props 之间的不匹配会触发构建错误。

- 共享 C++ 核心：渲染器是用 C++ 实现的，核心在平台之间共享。 这提高了一致性，并且更容易在新平台上采用 React Native。

- 更好的主机平台互操作性：同步和线程安全的布局计算改善了将原生组件嵌入 React Native 时的用户体验，这意味着更容易与需要同步 API 的主机平台框架集成。

- 改进的性能：随着渲染器系统新的跨平台实现，每个平台都会受益于这样的性能改进，这可能是由一个平台的限制所推动的。例如，视图扁平化最初是 Android 的一种性能解决方案，现在 Android 和 iOS 都默认提供。

- 一致性：新的渲染系统是跨平台的，更容易在不同平台之间保持一致性。

- 更快的启动：默认情况下，原生组件是延迟初始化的。

- JS 和宿主平台之间的数据序列化更少：React 用于在 JavaScript 和宿主平台之间以序列化 JSON 的形式传输数据。新的渲染器通过使用 JavaScript 接口 (JSI) 直接访问 JavaScript 值来改进数据传输。

> 术语解释：
> JavaScript Interfaces (JSI)：将 JavaScript 引擎嵌入 C++ 应用程序的轻量级 API。 Fabric 使用它在 Fabric 的 C++ 核心和 React 之间进行通信。

## 渲染、提交和挂载

React Native 渲染器通过一系列工作将 React 逻辑渲染到主机平台。 这一系列工作称为渲染管道，用于初始渲染和更新 UI 状态。 本文档介绍了渲染管道以及它在这些场景中的不同之处。

渲染管道可以分为三个一般阶段：

- 渲染：React 执行应用逻辑，在 JavaScript 中创建 React 元素树。根据这棵树，渲染器在 C++ 中创建一个 React Shadow Tree。

- 提交：React Shadow Tree 完全创建后，渲染器将触发提交。此时会将 React Element Tree 和新创建的 React Shadow Tree 提升为要挂载的“下一棵树”。这里面也包含了其布局信息的计算。

- 挂载：React Shadow Tree，现在连同布局计算的结果，将被转换为 Host View Tree。

> 渲染管道的阶段可能发生在不同的线程上。 有关详细信息，请参阅线程模型文档。

<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-07-15-084019.png" alt="image-20220715164019028" style="zoom:50%;" />

### 初始渲染

假设您要渲染以下内容：

```js
function MyComponent() {
  return (
    <View>
      <Text>Hello, World</Text>
    </View>
  );
}

// <MyComponent />
```

在上面的例子中，<MyComponent /> 是一个 React 元素。 React 通过调用它（如果是使用 JavaScript 类实现则调用它的 render 方法）递归地将这个 React 元素缩减为终端 React 主机组件，直到每个 React 元素都不能被进一步缩减。现在你有一个 React 主机组件的 React 元素树。

#### 阶段一：渲染

![image-20220715164039531](https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-07-15-084040.png)

在这个元素缩减的过程中，随着每个 React Element 的调用，渲染器也会同步创建一个 React Shadow Node。这只发生在 React 主机组件，而不是 React Composite 组件。在上面的示例中，\<View> 导致创建 ViewShadowNode 对象，\<Text> 导致创建 TextShadowNode 对象。 值得注意的是，从来没有直接代表 \<MyComponent> 的 React Shadow Node。

每当 React 在两个 React 元素节点之间创建父子关系时，渲染器都会在相应的 React 影子节点之间创建相同的关系。 这就是 React Shadow Tree 的组装方式。

额外细节

- 从（创建 React Shadow 节点以及创建两个 React Shadow 节点之间的父子关系）React (JavaScript) 到渲染器 (C++) 的执行操作是同步的，并且是线程安全的操作。该操作通常在 JavaScript 线程上执行。

- React 元素树（及其组成的 React 元素节点）不会无限期地存在。它是由 React 中的“fibers”具体化的时间表示。每个代表主机组件的“fiber”都存储一个指向 React Shadow Node 的 C++ 指针，这由 JSI 实现。

- React Shadow Tree 是不可变的。为了更新任何 React Shadow 节点，渲染器会创建一个新的 React Shadow Tree。但是，渲染器提供了克隆操作以使状态更新更高效。

在上面的示例中，渲染阶段的结果如下所示：

![image-20220715164056410](https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-07-15-084056.png)

React Shadow Tree 完成后，渲染器会触发 React Element Tree 的提交。

#### 阶段二：提交

![image-20220715164112806](https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-07-15-084113.png)

提交阶段包括两个操作：布局计算和 Tree 提升。

- 布局计算：此操作计算每个 React Shadow Node 的位置和大小。在 React Native 中，这涉及调用 Yoga 来计算每个 React Shadow 节点的布局。实际计算需要来自 JavaScript 中的 React 元素的每个 React Shadow 节点的样式。它还需要 React Shadow Tree 根的布局约束，它决定了结果节点可以占用的可用空间量。

![image-20220715164128686](https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-07-15-084129.png)

> 备注：Litho 和 Yoga 都是基于 Flexbox，Flexbox 是一种布局模式，标准来自于前端 CSS，可以理解为类似 Linear Layout 提供的一种布局规范。其中 Litho 底层依赖于 Yoga 部分模块，但是两者在原理上有一些区别。

- 树提升（新树 → 下一棵树）：此操作将新的 React Shadow Tree 提升为要挂载的“下一棵树”。这个提升表明新的 React Shadow Tree 已经拥有了所有要挂载的信息，并且代表了 React Element Tree 的最新状态。“下一棵树”安装在 UI 线程的下一个“tick”上。

额外细节

- 这些操作在后台线程上异步执行。

- 大多数布局计算完全在 C++ 中执行。 但是，某些组件的布局计算取决于宿主平台（例如 Text、TextInput 等）。文本的大小和位置是每个主机平台特定的，需要在主机平台层进行计算。为此，Yoga 调用宿主平台中定义的函数来计算组件的布局。

#### 阶段三：挂载

![image-20220715164145639](https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-07-15-084146.png)

挂载阶段将 React Shadow Tree（现在包含来自布局计算的数据）转换为在屏幕上呈现像素的主机视图树。提醒一下，React 元素树如下所示：

```js
<View>
  <Text>Hello, World</Text>
</View>
```

在高层次上，React Native 渲染器为每个 React Shadow Node 创建一个对应的 Host View 并将其安装在屏幕上。

在上面的示例中，渲染器为 \<View> 创建了一个 android.view.ViewGroup 实例，为 \<Text> 创建了一个 android.widget.TextView 实例，并用“Hello World”填充它。

同样，对于 iOS，创建 UIView 并使用对 NSLayoutManager 的调用填充文本。

每个 Host View 都将会使用使用来自其 React Shadow 节点的 props 来计算出的布局信息配置其大小和位置。

![image-20220715164200535](https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-07-15-084201.png)

更详细地说，安装阶段包括以下三个步骤：

- 树的 Diffing 计算：此步骤完全在 C++ 中计算“先前渲染的树”和“下一个树”之间的差异。计算结果是为了要在 Host View 上执行原子级别的变化操作（例如 createView、updateView、removeView、deleteView 等）。这一步也是 React Shadow Tree 被展平的地方，以避免创建不必要的 Host View。

- 树提升（下一棵树 → 渲染树）：此步骤以原子方式将“下一个树”提升为“前一次渲染树”，以便在下一个挂载阶段计算与新树的差异。

- 视图挂载：此步骤会调用平台提供的原子级别的操作方法来渲染视图。该步骤在平台的 UI 线程中执行。

额外细节

- 这些操作在 UI 线程上同步执行。 如果提交阶段在后台线程上执行，则为 UI 线程的下一个“tick”安排挂载阶段。另一方面，如果提交阶段在 UI 线程上执行，则挂载阶段在同一线程上同步执行。

- 挂载阶段的调度、实现和执行很大程度上取决于主机平台。 例如，目前 Android 和 iOS 的挂载层的渲染器架构是不同的。

- 在初始渲染期间，“前一次的渲染树”是空的。 因此，树的 Diffing 计算步骤将产生一个仅包括创建视图、设置道具和相互添加视图的操作列表。在处理 React 状态更新时，树的 Diffing 计算对于提升性能来讲变得至关重要。

- 在当前的生产测试中，React Shadow Tree 通常由大约 600-1000 个 React Shadow 节点组成（在视图展平之前），在视图展平后树会减少到约 200 个节点。在 iPad 或桌面应用程序上，这个数量可能会增加 10 倍。

### React 状态更新

当 React 元素树的状态更新时，让我们探索渲染管道的每个阶段。

假设您在初始渲染中渲染了以下组件：

```js
function MyComponent() {
  return (
    <View>
      <View style={{ backgroundColor: "red", height: 20, width: 20 }} />
      <View style={{ backgroundColor: "blue", height: 20, width: 20 }} />
    </View>
  );
}
```

根据初始渲染部分中描述的内容，我们知道会创建以下树：

![image-20220715164221460](https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-07-15-084222.png)

请注意，节点 3 所映射的具有红色背景的主机视图，以及节点 4 映射到的具有蓝色背景的主机视图。假设由于 JavaScript 产品逻辑中的状态更新，第一个嵌套 \<View> 的背景从“红色”变为“黄色”。这是新的 React 元素树的外观：

```js
<View>
  <View style={{ backgroundColor: "yellow", height: 20, width: 20 }} />
  <View style={{ backgroundColor: "blue", height: 20, width: 20 }} />
</View>
```

React Native 是如何处理这个更新的？

当状态更新发生时，渲染器首先需要更新 React 元素树，从而以便更新已经挂载的 Host 视图。但是为了保持线程安全，React Element Tree 和 React Shadow Tree 都必须是不可变的。这意味着，不是改变当前的 React Element Tree 和 React Shadow Tree，React 必须为每棵树创建一个新的副本，其中包含新的 props、styles 和 children。

让我们在状态更新期间探索渲染管道的每个阶段。

#### 阶段一：渲染

![image-20220715164255498](https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-07-15-084256.png)

当 React 创建一个包含新状态的新 React 元素树时，它必须克隆每个受更改影响的 React 元素和 React Shadow 节点。 克隆后，新的 React Shadow Tree 被提交。

React Native 渲染器利用结构共享来最小化开销。当一个 React 元素被克隆时，副本会包含新的状态，并且该元素到根结点上的所有 React 元素都会被克隆。React 只有在需要更新其 props、style 或 children 时才会克隆 React Element。状态更新未更改的任何 React 元素都由新旧树共享。

在上面的示例中，React 使用以下操作创建新树：

- CloneNode(节点 3, {backgroundColor: 'yellow'}) → 节点 3'
- CloneNode（节点 2）→ 节点 2'
- AppendChild（节点 2'，节点 3'）
- AppendChild（节点 2'，节点 4）
- CloneNode（节点 1）→ 节点 1'
- AppendChild（节点 1'，节点 2'）

在这些操作之后，节点 1' 代表新的 React 元素树的根。我们使用 T 代表“上一次的渲染树”，使用 T' 表示“新树”：

![image-20220715164311388](https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-07-15-084311.png)

注意 T 和 T' 将会共享节点 4。结构共享提高了性能并减少了内存使用。

#### 阶段二：提交

![image-20220715164326525](https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-07-15-084326.png)

在 React 创建新的 React Element Tree 和 React Shadow Tree 之后，将会提交它们。

- 布局计算：类似于初始渲染期间的布局计算。 一个重要的区别是布局计算可能会导致共享的 React 影子节点被克隆。 发生这种情况是因为如果共享 React Shadow Node 的父级发生布局更改，则共享 React Shadow Node 的布局也可能发生更改。

- 树提升（新树 → 下一棵树）：类似于初始渲染期间的树提升。

- 树 Diffing 计算：此步骤计算“先前渲染的树”（T）和“下一个树”（T'）之间的差异。计算结果会被用于调用主机对应的原子级别的视图变化操作。

  - 在上面的例子中，操作包括：UpdateView(Node 3', {backgroundColor: '“yellow”})

#### 阶段三：挂载

![image-20220715164341742](https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-07-15-084342.png)

- 树提升（下一棵树 → 渲染树）：此步骤以原子方式将“下一棵树”提升为“先前渲染的树”，以便下一个挂载阶段计算与新树的差异。任何已经挂载的树与新树之间都可以进行 Diff 计算。渲染器可以跳过树的一些中间版本。
- 视图挂载：此步骤会调用主机对应的原子级别的修改操作方法。在上面的例子中，只有 View 3 的 backgroundColor 会被更新（变成黄色）。

![image-20220715164358434](https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-07-15-084359.png)

## React Native 渲染器状态更新

对于 Shadow Tree 中的大多数信息，React 是唯一的所有者和唯一的事实来源。 所有数据都来自 React，并且存在单向数据流。

但是，有一个重要的机制是一个例外，那就是 C++ 中的组件可以包含不直接暴露给 JavaScript 的状态，此时 JavaScript 就不是事实的来源。C++ 和平台来控制此 C++ 状态。通常，这仅在您开发需要 C++ 状态的复杂主机组件时才相关。绝大多数主机组件不需要此功能。

例如，ScrollView 使用这种机制让渲染器知道当前偏移量是多少。因为更新是从宿主平台所触发的，特别是从代表 ScrollView 组件的宿主视图。在测量相关的 API 中会使用有关偏移量的信息。由于此更新源于主机平台，并且不影响 React Element Tree，因此此状态数据由 C++ State 保存。

从概念上讲，C++ 状态更新类似于上面描述的 React 状态更新。但是有两个重要区别：

1. 他们跳过“渲染阶段”，因为不涉及 React。

2. 更新可以在任何线程上发起和发生，包括主线程。

#### 阶段二：提交

![image-20220715164415905](https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-07-15-084416.png)

在执行 C++ 状态更新时，代码块请求更新 ShadowNode (N) 以将 C++ 状态设置为值 S。React Native 渲染器将反复尝试获取 N 的最新提交版本，将其克隆为新状态 S，并将 N' 提交到树。如果 React 或另一个 C++ 状态更新在此期间执行了另一个提交，则 C++ 状态提交将失败，渲染器将多次重试 C++ 状态更新，直到提交成功。 这可以防止真相来源的冲突和竞争。

#### 阶段三：挂载

![image-20220715164434472](https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-07-15-084435.png)

挂载阶段实际上与 React 状态更新的挂载阶段相同。渲染器仍然需要重新计算布局执行树差异等。有关详细信息，请参阅上面的部分。

## 实现跨平台

React Native 渲染器利用核心渲染实现跨平台共享。

在之前的 React Native 渲染系统中，React Shadow Tree、布局逻辑、View Flattening 算法每个平台都实现了一次。 当前的渲染器通过共享核心 C++ 实现从而变为了一个跨平台解决方案。

React Native 团队打算将动画系统整合到渲染系统中，并将 React Native 渲染系统扩展到 Windows 等新平台，以及游戏机、电视等的操作系统。

将 C++ 用于核心渲染系统引入了几个优点。 单一实现降低了开发和维护成本。它提高了创建 React Shadow 树和布局计算的性能，因为在 Android 上将 Yoga 与渲染器集成的开销最小化（即，不再有用于 Yoga 的 JNI）。最终，每个 React Shadow Node 在 C++ 中的内存占用比从 Kotlin 或 Swift 分配的要小。

> JNI（Java Native Interface）注：用于编写 Java 原生方法的 API，用于在 Fabric 的 C++ 核心和 Android 之间进行通信，用 Java 编写。

该团队还利用了强制不可变性的 c++特性，以确保对共享但不受保护的资源的并发访问不会出现问题。

重要的是要认识到，Android 的渲染器用例仍然会在两个主要用例中产生 JNI 成本：

- 复杂视图（例如 Text、TextInput 等）的布局计算需要通过 JNI 发送 props。

- 挂载阶段需要通过 JNI 发送修改操作。

该团队正在探索用一种新机制替换 ReadableMap，以使用 ByteBuffer 序列化数据以减少 JNI 的开销。 我们的目标是将 JNI 的开销减少 35-50%。

渲染器提供了其 C++ API 的两个方面：

- (i) 与 React 通信

- (ii) 与主机平台通信

对于 (i)，React 与渲染器通信以渲染 React 树并“监听”事件（例如 onLayout、onKeyPress、触摸等）。

对于 (ii)，React Native 渲染器与宿主平台通信以在屏幕上挂载宿主视图（创建、插入、更新或删除宿主视图），并监听用户在宿主平台上生成的事件。

![image-20220715164507790](https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-07-15-084508.png)

## 扁平化视图

View Flattening 是 React Native 渲染器的一种优化，用于避免深度布局树。

React API 通过组合被设计成声明性的和可重用的。这为直观开发提供了一个很好的模型。然而，在实现中，API 的这些特性导致了创建的 React Element Trees 有一定的深度，不过其中大部分的 React Element node 只影响视图的布局，而不会在屏幕上呈现任何东西。我们称这些类型的节点为“Layout-Only”节点。

从概念上讲，React Element Tree 的每个节点都与屏幕上的视图有 1:1 的关系，因此渲染一个由大量“Layout-Only”节点组成的深度 React Element Tree 会导致渲染时性能较差。

下面是一个受“Layout Only”视图成本影响的常见用例。

假设您想要呈现一个由 TitleComponent 处理的图像和标题，并且将该组件包含为 ContainerComponent 的子组件，该组件具有一些边距样式。在分解组件之后，React 代码看起来像这样:

```js
function MyComponent() {
  return (
    <View>                          // ReactAppComponent
      <View style={{margin: 10}} /> // ContainerComponent
        <View style={{margin: 10}}> // TitleComponent
          <Image {...} />
          <Text {...}>This is a title</Text>
        </View>
      </View>
    </View>
  );
}
```

作为渲染过程的一部分，React Native 将生成以下树:

![image-20220715164544442](https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-07-15-084544.png)

注意，视图(2)和(3)是“Layout-Only”视图，因为它们是在屏幕上渲染的，但它们只在子视图的顶部渲染 10 像素的边距。

为了提高这些类型的 React Element tree 的性能，渲染器实现了一个视图扁平化机制，该机制合并或扁平化这些类型的节点，减少了呈现在屏幕上的宿主视图层次结构的深度。这个算法考虑了像 margin, padding, backgroundColor，opacity 等属性。

视图扁平化算法被设计为渲染器 diffing 阶段的一部分，这意味着我们不需要使用额外的 CPU 周期来优化 React Element Tree 来扁平化这些类型的视图。作为核心的其他部分，视图扁平化算法是用 c++实现的，它的好处默认在所有支持的平台上共享。

在前面的示例中，视图 (2) 和 (3) 将作为“差异算法”的一部分被扁平化，因此它们的样式将合并到视图 (1) 中：

![image-20220715164606651](https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-07-15-084607.png)

需要注意的是，这种优化允许渲染器避免创建和渲染两个宿主视图。 从用户的角度来看，屏幕上没有可见的变化。

## 线程模型

React Native 渲染器将渲染管道的工作分配给多个线程。

在这里，我们定义了线程模型并提供了一些示例来说明渲染管道的线程使用情况。

React Native 渲染器被设计为线程安全的。 通过在框架内部使用不可变的数据结构（由 C++“const 正确性”特性强制执行），可以保证高级别的线程安全。 这意味着 React 中的每次更新都会在渲染器中创建或克隆新对象，而不是更新数据结构。 这允许框架向 React 公开线程安全和同步的 API。

渲染器使用三个不同的线程：

- UI 线程（通常称为 main）：唯一可以操作主机视图的线程。
- JavaScript 线程：这是执行 React 的渲染阶段的地方。
- 后台线程：专用于布局的线程。

让我们回顾一下每个阶段支持的执行场景：

<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-07-15-084638.png" alt="image-20220715164637383" style="zoom:50%;" />

## 渲染场景

### 在后台线程中渲染

这是最常见的场景，大多数渲染管道发生在 JavaScript 和后台线程上。

![image-20220715164656967](https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-07-15-084657.png)

### 在 UI 线程中渲染

当 UI 线程上有高优先级事件时，渲染器能够在 UI 线程上同步执行所有的渲染管道。

![image-20220715164711532](https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-07-15-084711.png)

### 默认或连续事件中断

这个场景显示了渲染阶段被 UI 线程中的低优先级事件中断。 React 和 React Native 渲染器能够中断渲染阶段并将其状态与在 UI 线程上执行的低优先级事件合并。 在这种情况下，渲染进程继续在后台线程中执行。

![image-20220715164726985](https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-07-15-084727.png)

### 离散事件中断

渲染阶段是可中断的。 这个场景显示了渲染阶段被 UI 线程中的高优先级事件中断。 React 和渲染器能够中断渲染阶段并将其状态与在 UI 线程上执行的高优先级事件合并。 渲染阶段在 UI 线程上同步执行。

![image-20220715164742326](https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-07-15-084742.png)

### 后台线程从 JavaScript 批量更新

在后台线程向 UI 线程发送更新之前，它会检查是否有来自 JavaScript 的更新。 这样，当渲染器知道有新状态进入时，它就不会渲染陈旧状态。

![image-20220715164756808](https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-07-15-084757.png)

### C++ 状态更新

源自 UI 线程的更新并跳过渲染阶段。 有关更多详细信息，请参阅 React Native 渲染器状态更新。

![image-20220715164812445](https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-07-15-084813.png)
